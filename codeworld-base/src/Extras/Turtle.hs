{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE PackageImports    #-}
{-# LANGUAGE RebindableSyntax #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ParallelListComp #-}
{-# LANGUAGE RecordWildCards #-}

module Extras.Turtle(
    Track, tracks, partialTracks
    , fd, bk, rt, lt, seth, setxy, home, pu, pd, overxy, sethome
    , repeat, run, foreach, forloop
    , polylines, dottylines, dottyline
    , turtle
    , example1, example2
    ) where

import Prelude
import Extras.Cw(slideshow)
import Extras.Op
import Extras.Util

data Turtle = Turtle
  { position :: Point
  , heading :: Point
  , trace :: [Point]
  , traces :: [[Point]]
  , pen :: Pen
  }

data Pen = Pu | Pd

homePosition = (0,0)
homeHeading = (0,1)

initial = Turtle
  { position = homePosition
  , heading = homeHeading
  , trace = [homePosition]
  , traces = []
  , pen = Pd
  }

-------------------------------------------------------------------------------
-- API
-------------------------------------------------------------------------------

type TurtleProgram = Turtle -> Turtle

-- | A Track is an open polyline.
-- Tracks are generated by Turtle commands.
type Track = [Point]

-- | Convert a Turtle command into a list of Tracks
tracks :: TurtleProgram -> [Track]
tracks(cmd) = initial.#cmd.#saveTrace.#reversed

-- | A list of all partial tracks corresponding to the given program.
-- Useful to observe the a step-by-step construction of the tracks.
partialTracks :: TurtleProgram -> [[Track]]
partialTracks(turtleProg) = foreach([2..sum(lengths)],partial)
  where
  fullTracks = tracks(turtleProg)
  fullLength = length(fullTracks)
  lengths = foreach(fullTracks,length)
  clengths = cumulativeSums(lengths)
  ctracks = zipped(clengths,fullTracks)
  partial(step)
    | n < fullLength = append(portion,taken)
    | otherwise = fullTracks
    where
    taken = selectedValues(ctracks,(<= step))
    n = length(taken)
    portion = first(fullTracks#(n+1),step - (0:clengths)#(n+1))

-- Turtle Language (standard)

-- | Move the Turtle forward by the given number of units
fd :: Number -> TurtleProgram
fd(len)(turtle) = turtle
  { position = position'
  , trace = turtle.#addPoint(position')
  }
  where
  position' = (px+len*hx,py+len*hy)
  (px,py) = turtle.#position
  (hx,hy) = turtle.#heading

-- | Move the Turtle backward by the given number of units
bk :: Number -> TurtleProgram
bk(len)(turtle) = turtle
  { position = position'
  , trace = turtle.#addPoint(position')
  }
  where
  position' = (px-len*hx,py-len*hy)
  (px,py) = turtle.#position
  (hx,hy) = turtle.#heading

-- | Turn the Turtle right (clockwise) by the given number of degrees
rt :: Number -> TurtleProgram
rt(angle)(turtle) = turtle
  { heading = rotatedPoint(turtle.#heading,-angle) }
  
-- | Turn the Turle left (counter-clockwise) by the given number of degrees
lt :: Number -> TurtleProgram
lt(angle)(turtle) = turtle
  { heading = rotatedPoint(turtle.#heading,angle) }

-- | Set Turtle heading by first orienting it upright (pointing upwards)
--   and then rotating it clockwise by the given number of degrees
seth :: Number -> TurtleProgram
seth(angle)(turtle) = turtle
  { heading = rotatedPoint(homeHeading,-angle) }

-- | Move the Turtle to the absolute position given by the X and Y coordinates
setxy :: Point -> TurtleProgram
setxy(x,y)(turtle) = turtle
  { position = (x,y)
  , trace = turtle.#addPoint(x,y)
  }

-- | Move the Turtle to the center
home :: TurtleProgram
home(turtle) = initial
  { trace = turtle.#addPoint(homePosition)
  , traces = turtle.#traces
  , pen = turtle.#pen
  }

-- | Pen Up: Stop tracing the positions of the Turtle
pu :: TurtleProgram
pu(turtle) = case turtle.#pen of
  Pu -> turtle
  Pd -> turtle
          { trace = []
          , traces = turtle.#saveTrace
          , pen = Pu
          }

-- | Pen Down: Start tracing the positions of the Turtle
pd :: TurtleProgram
pd(turtle) = case turtle.#pen of
  Pd -> turtle
  Pu -> turtle
          { trace = [turtle.#position]
          , pen = Pd
          }

-- Turtle Language Extensions

-- | Move the Turtle according to the given Point transformation
overxy :: (Point -> Point) -> TurtleProgram
overxy(f)(turtle) = turtle
  { position = p
  , trace = turtle.#addPoint(p)
  }
  where
  p = f(turtle.#position)

-- | Set the starting point for the trace to the given coordinates
sethome :: Point -> TurtleProgram
sethome(x,y)(turtle) = turtle
  { position = (x,y)
  , trace = case turtle.#pen of
                Pu -> []
                Pd -> [(x,y)]
  }

-- Drawing API Extensions

-- | Draw a track as a list of polylines
polylines :: [Track] -> Picture
polylines(ls) = ls.$polyline.#pictures

-- | Draw all the points in all the polylines in a Track
dottylines :: [Track] -> Picture
dottylines(ls) = ls.$dottyline.#pictures

-- | Draw the vertices of a polyline as dots
dottyline :: [Point] -> Picture
dottyline(pts) = pts.$makeDot.#pictures
  where
  makeDot(x,y) = translated(solidCircle(0.05),x,y)

turtle = run([ rt(150), fd(0.2), lt(120), fd(0.2), lt(60), fd(0.4), lt(120)
             , fd(0.4), lt(60), fd(0.2), lt(120), fd(0.2), lt(30)
             ])
  
-------------------------------------------------------------------------------
-- Turtle Aux
-------------------------------------------------------------------------------

addPoint :: Point -> Turtle -> [Point]
addPoint(p)(turtle) = case turtle.#pen of
  Pu -> turtle.#trace
  Pd -> p : turtle.#trace

saveTrace :: Turtle -> [[Point]]
saveTrace(turtle) = case turtle.#trace of
  [] -> turtle.#traces
  [_] -> turtle.#traces
  pts -> reversed(pts) : turtle.#traces
            

-- x .# f = f(x)

-- Examples

example1 = (stars.#run.#tracks.#polylines & anchors.#polyline).#drawingOf
  where
  noStar(l) = run([pu,star(l),pd])
  star(l) = run([repeat(8,[fd(l/30),rt(135)]),pu,fd(3*l/30),rt(57),pd])
  tracedStar(l) = run([star(l),pu,fd(3*l/30),rt(57),pd])
  stars = foreach( [0,4..120], star)
  anchors = foreach([0,4..120], noStar).#run.#tracks.#concatenation

-- Examples from the Logo 15-word challenge
-- http://www.mathcats.com/gallery/15wordcontest.html
 
example2 = (slides.$make ++ [bullring.#run.#tracks.#dottylines]).#slideshow
  where
  make(i,l,s) = blank
    & translated(text(i <> ": " <> l),0,9.5) 
    & translated(colored(solidRectangle(10,1.2),white),0,9.5)
    & s.#run.#tracks.#polylines

  slides =
    [ ("rep 1", "figs(14, poly(7,2))",figs(14, poly(7,2)))
    , ("rep 1", "ring",ring)
    , ("rep 1", "blade",blade)
    , ("rep 2", "hypercube",hypercube)
    , ("rep 2", "star1",star1)
    , ("rep 2", "fanflower",fanflower)
    , ("rep 2", "jagged1",jagged1)
    , ("rep 2", "jagged2",jagged2)
    , ("rep 2", "jagged3",jagged3)
    , ("rep 2", "pentahexa",pentahexa)
    , ("rep 3", "leaves(3)",leaves(3))
    , ("rep 3", "leaves(7)",leaves(7))
    , ("foreach", "roses(5,5,3)",roses(5,5,3))
    , ("foreach", "roses(5,12,5)",roses(5,12,5))
    , ("foreach", "bullring",bullring)
    , ("foreach", "squareSpiral",squareSpiral)
    , ("foreach", "diaphragm",diaphragm)
    , ("foreach+rep 1", "octagons",octagons)
    , ("foreach+rep 1", "circleSpiral",circleSpiral)
    , ("foreach+rep 1", "pentaStarSpiral",pentaStarSpiral)
    , ("foreach+rep 1", "octaStarSpiral",octaStarSpiral)
    , ("foreach+rep 1", "sqcirc1",sqcirc1)
    , ("foreach+rep 2", "pentapenta",pentapenta)
    , ("foreach+rep 2", "hexagon2",hexagon2)
    , ("foreach+rep 2", "hexagon1",hexagon1)
    , ("foreach+trig", "jaggystar",jaggystar)
    , ("foreach+trig", "fish1",fish1)
    , ("foreach+trig", "fish2",fish2)
    , ("foreach+trig", "gillyflower",gillyflower)
    , ("foreach+trig", "petals(7)",petals(7))
    , ("foreach+trig+log", "eye",eye)
    , ("forloop+trig", "spirotunnel",spirotunnel)
    , ("forloop+trig", "neutronStar",neutronStar)
    ]

  test = [repeat(8,[clover,rt(45)])]
    where
    n = 3
    base = repeat(90,[fd(0.1),rt(2)])
    clover = repeat(n,[base,rt(90)])
  
  figs(n,fig) = [repeat(n,[run(fig),lt(360/n)])]
  poly(n,len) = figs(n,[fd(len)])

  leaves(n) = -- Useful values for n: 1 to 7
    sethome(-2.7,-1.2)
    : [repeat(8,[rt(45),repeat(n,[repeat(90,[fd(0.1),rt(2)]),rt(90)])])]
  
  spirotunnel =
    forloop( 1,(<= 160),\i -> i + sin(i)
           , \i -> run([fd(i/80),bk(i/10),rt(51)])
           )
                     
  hexagon1 = foreach( [100,50..50]
                , \i -> repeat(6,[repeat(6,[fd(i/20),lt(60)]),lt(60)]))

  hexagon2 = foreach( [100,95..10]
                , \i -> repeat(6,[repeat(6,[fd(i/20),lt(60)]),lt(60)]))

  pentahexa = sethome(-0.5,-2)
    : [repeat(5,[repeat(6,[fd(4),lt(72)]),lt(144)])]

  fanflower = sethome(-1.5,5)
              : [repeat(12,[repeat(75,[fd(4),bk(4),rt(2)]),fd(10)])]

  fish1 = foreach([1..360],\t -> run(cmds(t)))
    where
    cmds(t) = [ overxy(\(x,y) -> (8*cos(2*t),y))
              , overxy(\(x,y) -> (x,x*cos(t)))
              , home
              ]
  
  fish2 = foreach([-315..315],\t -> setxy(t*sin(t)/50,0.5*t*cos(2*t)/50))
  
  blade = let fd'(x) = fd(x/20)
              bk'(x) = bk(x/20)
          in sethome(-3,-4)
             : [repeat(36,[fd'(60),rt(61),bk'(80),lt(41),fd'(85),rt(41)])]

  ring = let fd'(x) = fd(x/20)
             bk'(x) = bk(x/20)
         in sethome(4,0)
            : [repeat(16,[fd'(85),lt(60),fd'(107),bk'(72),lt(53),fd'(74)])]
  
  diaphragm = foreach([1..100],\i -> let fd'(x) = fd(x/20)
    in run([fd'(5+i),rt(45),fd'(10+i),rt(60)]))
  
  sqcirc1 =
    foreach( [1..36]
       , \i -> run([repeat(36,[fd(0.5),rt(10)]),fd(i/20),rt(90),fd(i/20)]))
  
  neutronStar =
    forloop(1,(<= 4),\i -> i + sin(i+7)/2
           ,\i -> let a = 2*i
                  in run([fd(a),bk(a),rt(41)]))

  gillyflower =
    foreach( [1..450]
           , \i -> let a = 73 * sin(i) in run([fd(a/20),rt(88*cos(a))]))
  
  eye = foreach([1..1800],\i -> run([fd(log(i)/10),bk(sin(i)),rt(10)]))
  
  jagged1 = sethome(0,-6) 
    : [repeat(4,[repeat(30,[lt(90),fd(0.2),rt(90),fd(0.2)]),rt(90)])]

  jagged2 = sethome(4,-6)
    : [repeat(4,[repeat(20,[lt(160),fd(1.5),rt(160),fd(1.5)]),rt(90)])]

  jagged3 = sethome(2.5,-7) : lt(5)
    : [repeat(8,[repeat(20,[lt(170),fd(1.5),rt(170),fd(1.5)]),rt(45)])]
    
  star1 = sethome(-2.5,-3.5)
    : [repeat(18,[repeat(5,[rt(40),fd(10),rt(120)]),rt(20)])]

  pentapenta =
    foreach([10,9..1],\i -> repeat(5,[repeat(5,[fd(i/2),lt(72)]),lt(72)]))
  
  pentaStarSpiral =
    foreach( [0,3..96]
           , \l -> run([repeat(5,[fd(l/20),rt(144)]),fd(l/20),rt(30)]))
  
  octaStarSpiral =
    foreach( [0,4..120]
       , \l -> run([repeat(8,[fd(l/30),rt(135)]),pu,fd(2*l/30),rt(30),pd]))

  hypercube = sethome(-3.5,1.5)
    : [repeat(8,[repeat(4,[rt(90),fd(3)]),bk(3),lt(45)])]
  
  petals(n) = foreach([0..180],\t -> run([seth(t),fd(10*sin(t*n)),home]))
  
  circleSpiral = foreach([0,0.05..4],\i -> repeat(180,[fd(i/10),rt(1)]))
  
  squareSpiral = foreach([1..800],\i -> run([fd(i/40),rt(89)]))

  roses(l,n,k) = foreach([1..360*n],\i -> run([fd(l/10),rt(i+x)]))
    where
    x = (2*k - n) / (2*n)
    -- Useful values:
    -- roses 5 5 3
    -- roses 5 7 3
    -- roses 5 10 7
    -- roses 5 12 5 

  octagons =
    foreach( [1..15]
       , \i -> repeat(5, [repeat(8, [fd (0.4 + i*0.2), rt(45)]), rt(72)])
       )
    
  bullring = sethome(3.25,-0.5)
    : foreach([0..1002],\i -> run([fd(0.4),seth(360*i^3 / 1002)]))
    
  jaggystar = fd(-6.5) 
            : foreach([0..2200],\i -> run([fd(0.75*sin(i)), rt(i^2)]))
  
