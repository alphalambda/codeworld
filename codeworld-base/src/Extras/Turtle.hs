{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE PackageImports    #-}
{-# LANGUAGE RebindableSyntax #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ParallelListComp #-}
{-# LANGUAGE RecordWildCards #-}

module Extras.Turtle
       ( Track, track, fd, bk, rt, lt, seth, setxy, home, pu, pd, overxy, sethome
       , polylines, dottylines, dottyline
       , example1, example2
       )
where

import Prelude
import Extras(rotatedPoint,slideshow,(<$>),run,foreach,forloop)
import qualified Extras as E

repeat = E.repeats

data Turtle = Turtle
  { position :: Point
  , heading :: Point
  , trace :: [Point]
  , traces :: [[Point]]
  , pen :: Pen
  }

data Pen = Pu | Pd

homePosition = (0,0)
homeHeading = (0,1)

initial = Turtle
  { position = homePosition
  , heading = homeHeading
  , trace = [homePosition]
  , traces = []
  , pen = Pd
  }

--------------------------------------------------------------------------------
-- API
--------------------------------------------------------------------------------

-- | A Track is a list of pointsets. Each pointset can be used to draw
-- a polyline. Tracks are generated by Turtle commands and usually
-- correspond to a list of polylines.
type Track = [[Point]]

-- | Convert a sequence of Turtle commands into the corresponding Track
track :: [Turtle -> Turtle] -> Track
track(cmds) = reversed(final.#saveTrace)
  where
  final = run(cmds)(initial)

-- Turtle Language (standard)

-- | Move the Turtle forward by the given number of units
fd :: Number -> Turtle -> Turtle
fd(len)(turtle) = turtle
  { position = position'
  , trace = turtle.#addPoint(position')
  }
  where
  position' = (px+len*hx,py+len*hy)
  (px,py) = turtle.#position
  (hx,hy) = turtle.#heading

-- | Move the Turtle backward by the given number of units
bk :: Number -> Turtle -> Turtle
bk(len)(turtle) = turtle
  { position = position'
  , trace = turtle.#addPoint(position')
  }
  where
  position' = (px-len*hx,py-len*hy)
  (px,py) = turtle.#position
  (hx,hy) = turtle.#heading

-- | Turn the Turtle right (clockwise) by the given number of degrees
rt :: Number -> Turtle -> Turtle
rt(angle)(turtle) = turtle
  { heading = rotatedPoint(turtle.#heading,-angle) }
  
-- | Turn the Turle left (counter-clockwise) by the given number of degrees
lt :: Number -> Turtle -> Turtle
lt(angle)(turtle) = turtle
  { heading = rotatedPoint(turtle.#heading,angle) }

-- | Set Turtle heading by first orienting it upright (pointing upwards)
--   and then rotating it clockwise by the given number of degrees
seth :: Number -> Turtle -> Turtle
seth(angle)(turtle) = turtle
  { heading = rotatedPoint(homeHeading,-angle) }

-- | Move the Turtle to the absolute position given by the X and Y coordinates
setxy :: Point -> Turtle -> Turtle
setxy(x,y)(turtle) = turtle
  { position = (x,y)
  , trace = turtle.#addPoint(x,y)
  }

-- | Move the Turtle to the center
home :: Turtle -> Turtle
home(turtle) = initial
  { trace = turtle.#addPoint(homePosition)
  , traces = turtle.#traces
  , pen = turtle.#pen
  }

-- | Pen Up: Stop tracing the positions of the Turtle
pu :: Turtle -> Turtle
pu(turtle) = case turtle.#pen of
  Pu -> turtle
  Pd -> turtle
          { trace = []
          , traces = turtle.#saveTrace
          , pen = Pu
          }

-- | Pen Down: Start tracing the positions of the Turtle
pd :: Turtle -> Turtle
pd(turtle) = case turtle.#pen of
  Pd -> turtle
  Pu -> turtle
          { trace = [turtle.#position]
          , pen = Pd
          }

-- Turtle Language Extensions

-- | Move the Turtle according to the given Point transformation
overxy :: (Point -> Point) -> Turtle -> Turtle
overxy(f)(turtle) = turtle
  { position = p
  , trace = turtle.#addPoint(p)
  }
  where
  p = f(turtle.#position)

-- | Set the starting point for the trace to the given coordinates
sethome :: Point -> Turtle -> Turtle
sethome(x,y)(turtle) = turtle
  { position = (x,y)
  , trace = case turtle.#pen of
                Pu -> []
                Pd -> [(x,y)]
  }

-- Drawing API Extensions

-- | Draw a track as a list of polylines
polylines :: Track -> Picture
polylines(ls) = pictures(polyline <$> ls)

-- | Draw all the points in all the polylines in a Track
dottylines :: Track -> Picture
dottylines(ls) = pictures(dottyline <$> ls)

-- | Draw the vertices of a polyline as dots
dottyline :: [Point] -> Picture
dottyline(pts) = pictures(makeDot <$> pts)
  where
  makeDot(x,y) = translated(solidCircle(0.05),x,y)
  
--------------------------------------------------------------------------------

-- Turtle Aux

addPoint :: Point -> Turtle -> [Point]
addPoint(p)(turtle) = case turtle.#pen of
  Pu -> turtle.#trace
  Pd -> p : turtle.#trace

saveTrace :: Turtle -> [[Point]]
saveTrace(turtle) = case turtle.#trace of
  [] -> turtle.#traces
  pts -> reversed(pts) : turtle.#traces
            

x .# f = f(x)

-- Examples

example1 = drawingOf(polylines(track(stars)) & polyline(anchors))
  where
  noStar(l) = run([pu,star(l),pd])
  star(l) = run([repeat(8,[fd(l/30),rt(135)]),pu,fd(3*l/30),rt(57),pd])
  tracedStar(l) = run([star(l),pu,fd(3*l/30),rt(57),pd])
  stars = foreach( [0,4..120], star)
  anchors = concatenation(track(foreach([0,4..120], noStar)))
 
example2 = slideshow((make <$> slides)
                    ++ [dottylines(track(bullring))]
                   )
  where
  make(i,l,s) = blank
    & translated(text(i <> ": " <> l),0,9.5) 
    & translated(colored(solidRectangle(10,1.2),white),0,9.5)
    & polylines(track(s))

  slides =
    [ ("rep 1", "figs(14, poly(7,2))",figs(14, poly(7,2)))
    , ("rep 1", "ring",ring)
    , ("rep 1", "blade",blade)
    , ("rep 2", "hypercube",hypercube)
    , ("rep 2", "star1",star1)
    , ("rep 2", "fanflower",fanflower)
    , ("rep 2", "jagged1",jagged1)
    , ("rep 2", "jagged2",jagged2)
    , ("rep 2", "jagged3",jagged3)
    , ("rep 2", "pentahexa",pentahexa)
    , ("rep 3", "leaves(3)",leaves(3))
    , ("rep 3", "leaves(7)",leaves(7))
    , ("foreach", "roses(5,5,3)",roses(5,5,3))
    , ("foreach", "roses(5,12,5)",roses(5,12,5))
    , ("foreach", "bullring",bullring)
    , ("foreach", "squareSpiral",squareSpiral)
    , ("foreach", "diaphragm",diaphragm)
    , ("foreach+rep 1", "octagons",octagons)
    , ("foreach+rep 1", "circleSpiral",circleSpiral)
    , ("foreach+rep 1", "pentaStarSpiral",pentaStarSpiral)
    , ("foreach+rep 1", "octaStarSpiral",octaStarSpiral)
    , ("foreach+rep 1", "sqcirc1",sqcirc1)
    , ("foreach+rep 2", "pentapenta",pentapenta)
    , ("foreach+rep 2", "hexagon2",hexagon2)
    , ("foreach+rep 2", "hexagon1",hexagon1)
    , ("foreach+trig", "jaggystar",jaggystar)
    , ("foreach+trig", "fish1",fish1)
    , ("foreach+trig", "fish2",fish2)
    , ("foreach+trig", "gillyflower",gillyflower)
    , ("foreach+trig", "petals(7)",petals(7))
    , ("foreach+trig+log", "eye",eye)
    , ("forloop+trig", "spirotunnel",spirotunnel)
    , ("forloop+trig", "neutronStar",neutronStar)
    ]

  test = [repeat(8,[clover,rt(45)])]
    where
    n = 3
    base = repeat(90,[fd(0.1),rt(2)])
    clover = repeat(n,[base,rt(90)])
  
  figs(n,fig) = [repeat(n,[run(fig),lt(360/n)])]
  poly(n,len) = figs(n,[fd(len)])

  leaves(n) = -- Useful values for n: 1 to 7
    sethome(-2.7,-1.2)
    : [repeat(8,[rt(45),repeat(n,[repeat(90,[fd(0.1),rt(2)]),rt(90)])])]
  
  spirotunnel =
    forloop( 1,(<= 160),\i -> i + sin(i)
           , \i -> run([fd(i/80),bk(i/10),rt(51)])
           )
                     
  hexagon1 = foreach( [100,50..50]
                , \i -> repeat(6,[repeat(6,[fd(i/20),lt(60)]),lt(60)]))

  hexagon2 = foreach( [100,95..10]
                , \i -> repeat(6,[repeat(6,[fd(i/20),lt(60)]),lt(60)]))

  pentahexa = sethome(-0.5,-2)
    : [repeat(5,[repeat(6,[fd(4),lt(72)]),lt(144)])]

  fanflower = sethome(-1.5,5)
              : [repeat(12,[repeat(75,[fd(4),bk(4),rt(2)]),fd(10)])]

  fish1 = foreach([1..360],\t -> run(cmds(t)))
    where
    cmds(t) = [ overxy(\(x,y) -> (8*cos(2*t),y))
              , overxy(\(x,y) -> (x,x*cos(t)))
              , home
              ]
  
  fish2 = foreach([-315..315],\t -> setxy(t*sin(t)/50,0.5*t*cos(2*t)/50))
  
  blade = let fd'(x) = fd(x/20)
              bk'(x) = bk(x/20)
          in sethome(-3,-4)
             : [repeat(36,[fd'(60),rt(61),bk'(80),lt(41),fd'(85),rt(41)])]

  ring = let fd'(x) = fd(x/20)
             bk'(x) = bk(x/20)
         in sethome(4,0)
            : [repeat(16,[fd'(85),lt(60),fd'(107),bk'(72),lt(53),fd'(74)])]
  
  diaphragm = foreach([1..100],\i -> let fd'(x) = fd(x/20)
    in run([fd'(5+i),rt(45),fd'(10+i),rt(60)]))
  
  sqcirc1 =
    foreach( [1..36]
       , \i -> run([repeat(36,[fd(0.5),rt(10)]),fd(i/20),rt(90),fd(i/20)]))
  
  neutronStar =
    forloop(1,(<= 4),\i -> i + sin(i+7)/2
           ,\i -> let a = 2*i
                  in run([fd(a),bk(a),rt(41)]))

  gillyflower =
    foreach([1..450],\i -> let a = 73 * sin(i) in run([fd(a/20),rt(88*cos(a))]))
  
  eye = foreach([1..1800],\i -> run([fd(log(i)/10),bk(sin(i)),rt(10)]))
  
  jagged1 = sethome(0,-6) 
    : [repeat(4,[repeat(30,[lt(90),fd(0.2),rt(90),fd(0.2)]),rt(90)])]

  jagged2 = sethome(4,-6)
    : [repeat(4,[repeat(20,[lt(160),fd(1.5),rt(160),fd(1.5)]),rt(90)])]

  jagged3 = sethome(2.5,-7) : lt(5)
    : [repeat(8,[repeat(20,[lt(170),fd(1.5),rt(170),fd(1.5)]),rt(45)])]
    
  star1 = sethome(-2.5,-3.5)
    : [repeat(18,[repeat(5,[rt(40),fd(10),rt(120)]),rt(20)])]

  pentapenta =
    foreach([10,9..1],\i -> repeat(5,[repeat(5,[fd(i/2),lt(72)]),lt(72)]))
  
  pentaStarSpiral =
    foreach([0,3..96],\l -> run([repeat(5,[fd(l/20),rt(144)]),fd(l/20),rt(30)]))
  
  octaStarSpiral =
    foreach( [0,4..120]
       , \l -> run([repeat(8,[fd(l/30),rt(135)]),pu,fd(2*l/30),rt(30),pd]))

  hypercube = sethome(-3.5,1.5)
    : [repeat(8,[repeat(4,[rt(90),fd(3)]),bk(3),lt(45)])]
  
  petals(n) = foreach([0..180],\t -> run([seth(t),fd(10*sin(t*n)),home]))
  
  circleSpiral = foreach([0,0.05..4],\i -> repeat(180,[fd(i/10),rt(1)]))
  
  squareSpiral = foreach([1..800],\i -> run([fd(i/40),rt(89)]))

  roses(l,n,k) = foreach([1..360*n],\i -> run([fd(l/10),rt(i+x)]))
    where
    x = (2*k - n) / (2*n)
    -- Useful values:
    -- roses 5 5 3
    -- roses 5 7 3
    -- roses 5 10 7
    -- roses 5 12 5 

  octagons =
    foreach( [1..15]
       , \i -> repeat(5, [repeat(8, [fd (0.4 + i*0.2), rt(45)]), rt(72)])
       )
    
  bullring = sethome(3.25,-0.5)
    : foreach([0..1002],\i -> run([fd(0.4),seth(360*i^3 / 1002)]))
    
  jaggystar = fd(-6.5) : foreach([0..2200],\i -> run([fd(0.75*sin(i)), rt(i^2)]))
  
